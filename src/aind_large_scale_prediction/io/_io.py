"""
Module that defines base Image Reader class
and the available metrics
"""

import os
from abc import ABC, abstractmethod, abstractproperty
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import dask.array as da
import imageio as iio
import numpy as np
import pims
import tifffile
import zarr
from dask.array.core import Array
from dask.base import tokenize
from dask_image.imread import imread as daimread
from skimage.io import imread as sk_imread

from aind_large_scale_prediction._shared.types import ArrayLike, PathLike

from .utils import add_leading_dim, read_json_as_dict


class ImageReader(ABC):
    """
    Abstract class to create image readers
    classes
    """

    def __init__(self, data_path: PathLike) -> None:
        """
        Class constructor of image reader.

        Parameters
        ------------------------
        data_path: PathLike
            Path where the image is located

        """

        self.__data_path = data_path
        super().__init__()

    @abstractmethod
    def as_dask_array(self, chunk_size: Optional[Any] = None) -> da.Array:
        """
        Abstract method to return the image as a dask array.

        Parameters
        ------------------------
        chunk_size: Optional[Any]
            If provided, the image will be rechunked to the desired
            chunksize

        Returns
        ------------------------
        da.Array
            Dask array with the image

        """
        pass

    @abstractmethod
    def as_numpy_array(self) -> np.ndarray:
        """
        Abstract method to return the image as a numpy array.

        Returns
        ------------------------
        np.ndarray
            Numpy array with the image

        """
        pass

    @abstractmethod
    def metadata(self) -> Dict:
        """
        Abstract method that return the image metadata.

        Returns
        -------
        Dict
            Dictionary with image metadata
        """
        pass

    @abstractmethod
    def close_handler(self) -> None:
        """
        Abstract method to close the image hander when it's necessary.

        """
        pass

    @abstractmethod
    def indexing(self, xv: np.array, yv: np.array) -> ArrayLike:
        """
        Abstract method to index arrays
        """
        pass

    @abstractproperty
    def shape(self) -> Tuple:
        """
        Abstract method to return the shape of the image.

        Returns
        ------------------------
        Tuple
            Tuple with the shape of the image

        """
        pass

    @abstractproperty
    def chunks(self) -> Tuple:
        """
        Abstract method to return the chunks of the image if it's possible.

        Returns
        ------------------------
        Tuple
            Tuple with the chunks of the image

        """
        pass

    @property
    def data_path(self) -> PathLike:
        """
        Getter to return the path where the image is located.

        Returns
        ------------------------
        PathLike
            Path of the image

        """
        return self.__data_path

    @data_path.setter
    def data_path(self, new_data_path: PathLike) -> None:
        """
        Setter of the path attribute where the image is located.

        Parameters
        ------------------------
        new_data_path: PathLike
            New path of the image

        """
        self.__data_path = new_data_path


class OMEZarrReader(ImageReader):
    """
    OMEZarr reader class
    """

    def __init__(
        self,
        data_path: PathLike,
        multiscale: Optional[str] = "0",
    ) -> None:
        """
        Class constructor of image OMEZarr reader.

        Parameters
        ------------------------
        data_path: PathLike
            Path where the image is located

        multiscale: Optional[str]
            Desired multiscale to read from the image. Default: "0"
            which is supposed to be the highest resolution

        """

        # Adding multiscale to path
        if isinstance(data_path, str):
            data_path = f"{data_path}/{multiscale}"

        else:
            data_path = data_path.joinpath(str(multiscale))

        super().__init__(data_path=data_path)
        self.lazy_image = da.from_zarr(self.data_path)

    def indexing(self, xv: np.array, yv: np.array) -> ArrayLike:
        """
        Indexes arrays using X and Y locations
        generated by a meshgrid

        Parameters
        ----------
        xv: np.array
            X locations generated by a meshgrid

        yv: np.array
            y locations generated by a meshgrid

        Returns
        ----------
        Data in provided locations
        """

        return self.lazy_image.vindex(xv, yv)

    def as_dask_array(self, chunk_size: Optional[Any] = None) -> da.array:
        """
        Method to return the image as a dask array.

        Parameters
        ------------------------
        chunk_size: Optional[Any]
            If provided, the image will be rechunked to the desired
            chunksize

        Returns
        ------------------------
        da.Array
            Dask array with the image

        """

        if chunk_size:
            return self.lazy_image.rechunk(chunks=chunk_size)

        return self.lazy_image

    def as_numpy_array(self):
        """
        Method to return the image as a numpy array.

        Returns
        ------------------------
        np.ndarray
            Numpy array with the image

        """
        return zarr.open(self.data_path, "r")[:]

    def metadata(self) -> Dict:
        """
        Returns the image metadata.

        Returns
        -------
        Dict
            Dictionary with image metadata
        """
        metadata = {}
        # Removing multiscale to path
        if isinstance(self.data_path, str):
            data_path = Path(self.data_path)

        zattrs_metadata = ""
        zarray_metadata = ""
        # Checking inside and outside of folder due to dimension separator "." or "/"
        for path in [data_path, data_path.parent]:
            if path.joinpath(".zattrs").exists():
                zattrs_metadata = path.joinpath(".zattrs")

            if path.joinpath(".zarray").exists():
                zarray_metadata = path.joinpath(".zarray")

        print(f"Reading metadata from {zattrs_metadata} and {zarray_metadata}")

        metadata[".zattrs"] = read_json_as_dict(zattrs_metadata)
        metadata[".zarray"] = read_json_as_dict(zarray_metadata)

        return metadata

    def close_handler(self) -> None:
        """
        Method to close the image hander when it's necessary.
        """
        pass

    @property
    def shape(self):
        """
        Method to return the shape of the image.

        Returns
        ------------------------
        Tuple
            Tuple with the shape of the image

        """
        return zarr.open(self.data_path, "r").shape

    @property
    def chunks(self):
        """
        Method to return the chunks of the image.

        Returns
        ------------------------
        Tuple
            Tuple with the chunks of the image

        """
        return zarr.open(self.data_path, "r").chunks


class TiffReader(ImageReader):
    """
    TiffReader class
    """

    def __init__(self, data_path: PathLike) -> None:
        """
        Class constructor of image Tiff reader.

        Parameters
        ------------------------
        data_path: PathLike
            Path where the image is located

        """
        super().__init__(data_path)
        self.tiff = tifffile.TiffFile(self.data_path)

    def indexing(self, xv: np.array, yv: np.array) -> ArrayLike:
        """
        Indexes arrays using X and Y locations
        generated by a meshgrid

        Parameters
        ----------
        xv: np.array
            X locations generated by a meshgrid

        yv: np.array
            y locations generated by a meshgrid

        Returns
        ----------
        Data in provided locations
        """

        return self.tiff.asarray()[xv, yv]

    def as_dask_array(
        self, shape: Optional[Any] = None, dtype: Optional[Any] = None
    ) -> da.Array:
        """
        Method to return the image as a dask array.

        Parameters
        ------------------------
        shape: Optional[Any]
            Shape of the image

        Returns
        ------------------------
        da.Array
            Dask array with the image

        """
        data_path = str(self.data_path)
        name = "imread-%s" % tokenize(
            data_path, map(os.path.getmtime, data_path)
        )

        if shape is None or dtype is None:
            with pims.open(data_path) as imgs:
                shape = (1,) + (len(imgs),) + imgs.frame_shape
                dtype = np.dtype(imgs.pixel_type)

        key = [(name,) + (0,) * len(shape)]
        value = [(add_leading_dim, (sk_imread, data_path))]
        dask_arr = dict(zip(key, value))
        chunk_size = tuple((d,) for d in shape)

        return Array(dask_arr, name, chunk_size, dtype)

    def metadata(self) -> Dict:
        """
        Returns the image metadata.

        Returns
        -------
        Dict
            Dictionary with image metadata
        """
        metadata = {}
        with pims.open(data_path) as imgs:
            metadata["shape"] = (1,) + (len(imgs),) + imgs.frame_shape
            metadata["dtype"] = np.dtype(imgs.pixel_type)

        return metadata

    def as_numpy_array(self) -> np.ndarray:
        """
        Abstract method to return the image as a numpy array.

        Returns
        ------------------------
        np.ndarray
            Numpy array with the image

        """
        return self.tiff.asarray()

    @property
    def shape(self) -> Tuple:
        """
        Abstract method to return the shape of the image.

        Returns
        ------------------------
        Tuple
            Tuple with the shape of the image

        """
        with pims.open(str(self.data_path)) as imgs:
            shape = (len(imgs),) + imgs.frame_shape

        return shape

    @property
    def chunks(self) -> Tuple:
        """
        Abstract method to return the chunks of the image if it's possible.

        Returns
        ------------------------
        Tuple
            Tuple with the chunks of the image

        """
        return self.tiff.aszarr().chunks

    def close_handler(self) -> None:
        """
        Closes image handler
        """
        if self.tiff is not None:
            self.tiff.close()
            self.tiff = None

    def __del__(self) -> None:
        """Overriding destructor to safely close image"""
        self.close_handler()


class PngReader(ImageReader):
    """
    PngReader class
    """

    def __init__(self, data_path: PathLike) -> None:
        """
        Class constructor of image PNG reader.

        Parameters
        ------------------------
        data_path: PathLike
            Path where the image is located

        """
        super().__init__(data_path)

    def indexing(self, xv: np.array, yv: np.array) -> ArrayLike:
        """
        Indexes arrays using X and Y locations
        generated by a meshgrid

        Parameters
        ----------
        xv: np.array
            X locations generated by a meshgrid

        yv: np.array
            y locations generated by a meshgrid

        Returns
        ----------
        Data in provided locations
        """
        return self.as_numpy_array[xv, yv]

    def as_dask_array(self, chunk_size: Optional[Any] = None) -> da.Array:
        """
        Method to return the image as a dask array.

        Parameters
        ------------------------
        chunk_size: Optional[Any]
            If provided, the image will be rechunked to the desired
            chunksize

        Returns
        ------------------------
        da.Array
            Dask array with the image

        """
        return daimread(self.data_path, arraytype="numpy")

    def as_numpy_array(self) -> np.ndarray:
        """
        Abstract method to return the image as a numpy array.

        Returns
        ------------------------
        np.ndarray
            Numpy array with the image

        """
        return np.array(iio.imread(self.data_path))

    @property
    def shape(self) -> Tuple:
        """
        Abstract method to return the shape of the image.

        Returns
        ------------------------
        Tuple
            Tuple with the shape of the image

        """
        with pims.open(str(self.data_path)) as imgs:
            shape = (len(imgs),) + imgs.frame_shape

        return shape

    def metadata(self) -> Dict:
        """
        Returns the image metadata.

        Returns
        -------
        Dict
            Dictionary with image metadata
        """
        metadata = {}
        with pims.open(data_path) as imgs:
            metadata["shape"] = (len(imgs),) + imgs.frame_shape

        return metadata

    @property
    def chunks(self) -> Tuple:
        """
        Abstract method to return the chunks of the image if it's possible.

        Returns
        ------------------------
        Tuple
            Tuple with the chunks of the image

        """
        return self.as_dask_array().chunksize

    def close_handler(self) -> None:
        """
        Closes image handler
        """
        pass

    def __del__(self) -> None:
        """Overriding destructor to safely close image"""
        self.close_handler()


class ImageReaderFactory:
    """
    Image reader factory class
    """

    def __init__(self):
        """
        Class to create the image reader factory.
        """
        self.__extensions = [".zarr", ".tif", ".tiff", ".png"]
        self.factory = {
            ".zarr": OMEZarrReader,
            ".tif": TiffReader,
            ".tiff": TiffReader,
            ".png": PngReader,
        }

    @property
    def extensions(self) -> List:
        """
        Method to return the allowed format extensions of the images.

        Returns
        ------------------------
        List
            List with the allowed image format extensions

        """
        return self.__extensions

    def create(
        self, data_path: PathLike, parse_path: Optional[bool] = True, **kwargs
    ) -> ImageReader:
        """
        Method to create the image reader based on the format.

        Parameters
        ----------
        data_path: PathLike
            Path where the data is located

        parse_path: Optional[bool]
            If True, parses the path with the pathlib.Path object.
            Not useful when we're trying to access data in S3.

        Returns
        -------
        List
            List with the allowed image format extensions

        """
        path_cast = Path(data_path) if parse_path else data_path
        ext = Path(data_path).suffix

        if ext not in self.__extensions:
            raise NotImplementedError(f"File type {ext} not supported")

        return self.factory[ext](path_cast, **kwargs)
